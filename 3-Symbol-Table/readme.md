# Intermediate Representation - Symbol Table

---

## 1. Introduction

In DJ, the symbol table is implemented in C and consists of two global structures, classesST and mainBlockST. These structures store essential information about each variable declared in the source code. This information is crucial for type checking and code generation in the later stages of compilation. Because classesST and mainBlockST are global, they can be easily accessed by other parts of the compiler. 

---

## 2. Type Convention

All DJ types are represented as integers for efficient comparison and assignment. Let int i denote the type.

1. i > 0: Represents the ith class declared in the source code. For example, i = 1 for the first user-defined class, i = 2 for the second user-defined class, and so on.

2. i = 0: Represents Object, the superclass for all user-defined classes.

3. i = -1: Represents nat, a natural number.

4. i = -2: Represents bool, true or false.

5. i = -3: Represents null or any object type, the subtype for all existing classes.

6. i = -4: Represents the superclass of Object, used by the compiler only to maintain the superclass entry of Object.

7. i < -4: Represents any undefined and illegal types.

---

## 3. Data Structures

```c
typedef struct varDecl {
  char *varName;
  int varNameLineNumber;
  int type;
  int typeLineNumber;
} VarDecl;

typedef struct methodDecl {
  char *methodName;
  int methodNameLineNumber;
  int returnType;
  int returnTypeLineNumber;
  char *paramName;
  int paramNameLineNumber;
  int paramType;
  int paramTypeLineNumber;

  //An array of this method's local variables
  int numLocals;
  VarDecl *localST;

  //The method's executable body
  ASTree *bodyExprs; 
} MethodDecl;

typedef struct classDecl {
  char *className;
  int classNameLineNumber;
  int superclass;
  int superclassLineNumber;

  //An array of static-variable information
  int numStaticVars; 
  VarDecl *staticVarList; 
 
  //An array of (non-static) variable information
  int numVars; 
  VarDecl *varList;

  //An array of method information
  int numMethods; 
  MethodDecl *methodList;
} ClassDecl;

//An array of locals in the main block
int numMainBlockLocals;
VarDecl *mainBlockST;
   
//An array of class declarations
int numClasses;
ClassDecl *classesST;
```

---

## 4. Implementation

The symbol table initializer processes the abstract syntax tree generated by the parser to gather information about each declared variable. 

#### 1. Process Main Block Locals
1. Identify the number of local variables in the main block.
2. Allocate memory for `mainBlockST` based on this size.
3. For each local variable, insert its name and line number, leaving the type blank.

#### 2. Process User-Defined Classes
1. Identify the number of user-defined classes.
2. Allocate memory for `classesST`.
3. Insert `Object` as the first entry in `classesST`.
4. For each class:
   1. Insert the class name and its line number.
   2. Identify the number of static variables.
   3. Allocate memory for the static variable list.
   4. For each static variable, insert its name and line number, leaving the type blank.
   5. Identify the number of non-static variables.
   6. Allocate memory for the non-static variable list.
   7. For each non-static variable, insert its name and line number, leaving the type blank.
   8. Identify the number of methods.
   9. Allocate memory for the method list.
   10. For each method:
       1. Insert the method name and its line number.
       2. Identify the number of local variables within the method.
       3. Allocate memory for the method's local variable list.
       4. For each local variable within the method, insert its name and line number.
       5. Leave the associate types blank

#### 3. Complete Type Information
1. Assign types to each local variable in the main block.
2. For each class:
   1. Assign the type and line number for the superclass.
   2. Assign types and line numbers to static variables.
   3. Assign types and line numbers to non-static variables.
   4. For each method:
       1. Assign types and line numbers to the return value and parameter.
       2. Assign types to the method's local variables.

